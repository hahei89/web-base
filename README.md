数据驱动
# vue与模板
1. 编写页面模板
    1. 直接在HTML标签中写 标签
    2. 使用template
    3. 使用单文件
2. 创建vue的实例
    1. 在vue的构造函数中提供：data, methods, computed, watcher, props,...
3. 将vue挂载到页面中(mount)
# 数据驱动模型
Vue 的执行流程  
   1. 获得模板: 模板中 '有坑'
   2. 利用Vue搞糟函数中所提供的数据来填坑，得到可以在页面中显示的 '标签'了
   3. 将标签 特换页面中原来有坑的标签
   Vue 利用我们提供的数据和 页面中 模板，生成了一个新的html标签(node 节点)，替换到了页面中防止模板的位置

# 简单的模板渲染

# 虚拟DOM
目标：
1. 怎么将真正的DOM转换为虚拟DOM?
2. 怎么将虚拟DOM转换为真正的DOM?

思路与深拷贝类似

# 函数柯里化
参考资料:

- [函数式编程](https://11h911001.gitbooks.io/mostly-adequate-guide-chinese/content/)

概念:
1. 柯里化: 一个函数原本有多个参数，只传入**一个**参数，生成一个新函数，由新函数来接收剩下的参数来运行得到结果
2. 偏函数: 一个函数原本有多个参数，只传入**一部分**参数，生成一个新函数，由新函数来接收剩下的参数来运行得到结果
3. 高阶函数: 一个函数参数是一个函数，该函数对参数这个函数进行加工，得到一个函数，这个加工用的函数就是高阶函数

为什么要使用柯里化？  为了提升性能，我们使用柯里化可以缓存一部分能力。
使用两个案例说明？
1. 判断元素
2. 虚拟DOM的render方法

1. 判断元素:
   
Vue 本质上是使用HTML的字符串作为模板的，将字符串的模板作为AST，再转换为VNode
- 模板 -> AST
- AST -> VNode
- VNode -> DOM

哪一个阶段最消耗性能? 

最消耗性能的是字符串解析(模板 -> AST)
例子: let s = "1 +2 * (3+4)"
写一个程序，解析这个表达式，得到结果(一般化)
一般会将这个表达式转换为"波兰式"表达式，然后用栈结构来运算  

在Vue中每一个标签可以是真正的HTML标签，也可以是Vue组件，怎么区分？

在Vue源码中将所有可用的HTML标签已经存起来了

假设只考虑几个标签:
```js
let tags = 'div, p, a, img, ul, li'.split(',')
```
需要一个函数，判断标签名是否为 内置的标签

```js
function isHTMLTag (tagName) {
    let tags = 'div, p, a, img, ul, li'.split(',')
    tagName = tagName.toLowerCase()
    return tags.some(val =>{
        return val === tagName
    })
}
```

模板是任意编写的，可以写的很简单，也可以写的很复杂， indexOf内部也是要循环的
如果有6中内置标签，而模板中有10个标签需要判断，那么至多需要执行60次循环

2. 虚拟DOM的render方法
   
思考：vue项目 *模板转换为抽象语法树* 需要几次？
- 页面一开始加载需要渲染
- 每一个属性(响应式)数据在发生变化的时候 要渲染
- watch computed等等

day01 中的代码每次需要渲染的时候，模板就会被解析一次(注意，这里我们简化了解析方法)
render的作用是将 虚拟DOM 转换为 真正的DOM加到页面中

- 虚拟DOM可以降级理解为AST
- 一个项目运行的时候模板是不会变的，就表示AST是不会变的
  
我们可以将代码进行优化，将虚拟DOM缓存起来，生成一个函数，函数只需要传入数据，就可以得到真正的DOM

# 响应式原理
- 我们在使用Vue的时候， 赋值数型获得属性都是直接使用的Vue实例
- 我们在设计属性值的时候， 页面的数据更新
```js
Object.defineProperty(obj, name, {
    writeble,
    configurble,
    enumerble,
    set,
    get
})
```
实际开发中 对象一般是由多级的
```js
let o = {
    list: {
        {}
    },
    ads: [
        {}
    ],
    user: {

    }
}
```
怎么处理？  递归或者队列
对于对象，可以使用递归来响应式化， 但是数组我们也需要处理
- push
- pop
- shift
- unshift
- reverse
- sort
- splice

要做什么事情呢？

1. 在改变数组的数据的时候要发出通知
    1. Vue2 的缺陷，数组发生变化，设置length没发通知(Vue3 中使用Proxy语法ES6的语法解决了这个问题)
    2. 加入的元素应该变成响应式的

技巧:

如果一个函数已经定义了，但是我们需要扩展其功能，一般的处理办法：

1. 使用一个临时的函数名称存储函数
2. 重新定义原来的函数
3. 定义扩展的功能
4. 调用临时的那个函数

扩展数组的push和pop怎么处理呢?
- 直接修改prototype不行 因为这意味着所有数组的prototype都改了
- 修改要进行响应式化的数组的原型(__proto__)

练习: 
    已经将对象改成响应式的了，但是如果直接给对象赋值，赋值另一个对象，就不是响应式的了，怎么办？？
    在set的时候，把value响应式化
# 发布订阅模式
任务：
    - 作业
    - 代理方法(app.name, app._data.name)
    - 事件模型(node: event 模块)
    - vue 中observer与watcher和Dep的关系

代理方法就是要将app._data中的成员映射到app上

由于需要在更新数据的时候，更新页面的内容
所以 app._data访问的成员 与 app 访问的成员应该是同一个成员

由于 app._data 已经是响应式的对象了，所以只需要让app访问的成员去访问app._data的对应成员就可以了

```js
app.name 转换为 app._data.name
```

引入了一个函数Proxy(target, src, prop) 将target与src的成员映射到一起

这里是因为当时没有`Proxy`语法(ES6)

我们之前处理的reactify方法已经不行了，我们需要一个新的方法来处理

提供一个Observer的方法，在这个方法当中 对属性进行处理
可以将这个方法封装到initData方法中