数据驱动
# vue与模板
1. 编写页面模板
    1. 直接在HTML标签中写 标签
    2. 使用template
    3. 使用单文件
2. 创建vue的实例
    1. 在vue的构造函数中提供：data, methods, computed, watcher, props,...
3. 将vue挂载到页面中(mount)
# 数据驱动模型
Vue 的执行流程  
   1. 获得模板: 模板中 '有坑'
   2. 利用Vue搞糟函数中所提供的数据来填坑，得到可以在页面中显示的 '标签'了
   3. 将标签 特换页面中原来有坑的标签
   Vue 利用我们提供的数据和 页面中 模板，生成了一个新的html标签(node 节点)，替换到了页面中防止模板的位置

# 简单的模板渲染

# 虚拟DOM
目标：
1. 怎么将真正的DOM转换为虚拟DOM?
2. 怎么将虚拟DOM转换为真正的DOM?

思路与深拷贝类似

# 函数柯里化
参考资料:

- [函数式编程](https://11h911001.gitbooks.io/mostly-adequate-guide-chinese/content/)

概念:
1. 柯里化: 一个函数原本有多个参数，只传入**一个**参数，生成一个新函数，由新函数来接收剩下的参数来运行得到结果
2. 偏函数: 一个函数原本有多个参数，只传入**一部分**参数，生成一个新函数，由新函数来接收剩下的参数来运行得到结果
3. 高阶函数: 一个函数参数是一个函数，该函数对参数这个函数进行加工，得到一个函数，这个加工用的函数就是高阶函数

为什么要使用柯里化？  为了提升性能，我们使用柯里化可以缓存一部分能力。
使用两个案例说明？
1. 判断元素
2. 虚拟DOM的render方法

1. 判断元素:
   
Vue 本质上是使用HTML的字符串作为模板的，将字符串的模板作为AST，再转换为VNode
- 模板 -> AST
- AST -> VNode
- VNode -> DOM

哪一个阶段最消耗性能? 

最消耗性能的是字符串解析(模板 -> AST)
例子: let s = "1 +2 * (3+4)"
写一个程序，解析这个表达式，得到结果(一般化)
一般会将这个表达式转换为"波兰式"表达式，然后用栈结构来运算  

在Vue中每一个标签可以是真正的HTML标签，也可以是Vue组件，怎么区分？

在Vue源码中将所有可用的HTML标签已经存起来了

假设只考虑几个标签:
```js
let tags = 'div, p, a, img, ul, li'.split(',')
```
需要一个函数，判断标签名是否为 内置的标签

```js
function isHTMLTag (tagName) {
    let tags = 'div, p, a, img, ul, li'.split(',')
    tagName = tagName.toLowerCase()
    return tags.some(val =>{
        return val === tagName
    })
}
```

模板是任意编写的，可以写的很简单，也可以写的很复杂， indexOf内部也是要循环的
如果有6中内置标签，而模板中有10个标签需要判断，那么至多需要执行60次循环

2. 虚拟DOM的render方法
   
思考：vue项目 *模板转换为抽象语法树* 需要几次？
- 页面一开始加载需要渲染
- 每一个属性(响应式)数据在发生变化的时候 要渲染
- watch computed等等

day01 中的代码每次需要渲染的时候，模板就会被解析一次(注意，这里我们简化了解析方法)
render的作用是将 虚拟DOM 转换为 真正的DOM加到页面中

- 虚拟DOM可以降级理解为AST
- 一个项目运行的时候模板是不会变的，就表示AST是不会变的
  
我们可以将代码进行优化，将虚拟DOM缓存起来，生成一个函数，函数只需要传入数据，就可以得到真正的DOM

